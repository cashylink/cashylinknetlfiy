import{aH as P}from"./index-CgV0sHeM.js";import{E as x}from"./ProtectedAdminDashboard-BIpEuHrG.js";import"./contentService-Bgh-eKcj.js";import"./ProfileIcon-CCS5CeGE.js";import"./dropdown-menu-CLdLSeyn.js";import"./index-BVTp5Qlg.js";import"./switch-CQytG77E.js";import"./freeTrialService-DU5AUvYv.js";import"./alert-Dp2JhWKK.js";import"./separator-CArj5DvN.js";import"./save-CK42wzuM.js";import"./gift-BCTVqinY.js";import"./broadcastService-DLuBcfgc.js";import"./bell-CyrMMN44.js";import"./calendar-0_98-YC1.js";import"./select-Cjxh7T8L.js";import"./zap-BGNh6qf_.js";import"./crown-2lrrj6PS.js";import"./star-DyMukElk.js";import"./circle-check-big-iKMCgwGI.js";import"./table-Ry-VsunV.js";import"./tabs-B1SNyKq6.js";import"./square-pen-B77-kNO1.js";import"./progress-BGmEOiQZ.js";import"./download-DwDr96vs.js";import"./users-DcT8Qdqe.js";import"./activity-BzRIRPYu.js";import"./monitor-BtjxvLUT.js";import"./pen-line-dJR2NKoC.js";function b(l){const e=l.split("/").filter(t=>t!=="."),r=[];return e.forEach(t=>{t===".."&&r.length>0&&r[r.length-1]!==".."?r.pop():r.push(t)}),r.join("/")}function E(l,e){l=b(l),e=b(e);const r=l.split("/"),t=e.split("/");return l!==e&&r.every((i,s)=>i===t[s])}class w extends P{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"]}async initDb(){if(this._db!==void 0)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((e,r)=>{const t=indexedDB.open(this.DB_NAME,this.DB_VERSION);t.onupgradeneeded=w.doUpgrade,t.onsuccess=()=>{this._db=t.result,e(t.result)},t.onerror=()=>r(t.error),t.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(e){const t=e.target.result;switch(e.oldVersion){case 0:case 1:default:t.objectStoreNames.contains("FileStorage")&&t.deleteObjectStore("FileStorage"),t.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(e,r){const t=this._writeCmds.indexOf(e)!==-1?"readwrite":"readonly";return this.initDb().then(i=>new Promise((s,a)=>{const c=i.transaction(["FileStorage"],t).objectStore("FileStorage")[e](...r);c.onsuccess=()=>s(c.result),c.onerror=()=>a(c.error)}))}async dbIndexRequest(e,r,t){const i=this._writeCmds.indexOf(r)!==-1?"readwrite":"readonly";return this.initDb().then(s=>new Promise((a,o)=>{const h=s.transaction(["FileStorage"],i).objectStore("FileStorage").index(e)[r](...t);h.onsuccess=()=>a(h.result),h.onerror=()=>o(h.error)}))}getPath(e,r){const t=r!==void 0?r.replace(/^[/]+|[/]+$/g,""):"";let i="";return e!==void 0&&(i+="/"+e),r!==""&&(i+="/"+t),i}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(e){const r=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[r]);if(t===void 0)throw Error("File does not exist.");return{data:t.content?t.content:""}}async writeFile(e){const r=this.getPath(e.directory,e.path);let t=e.data;const i=e.encoding,s=e.recursive,a=await this.dbRequest("get",[r]);if(a&&a.type==="directory")throw Error("The supplied path is a directory.");const o=r.substr(0,r.lastIndexOf("/"));if(await this.dbRequest("get",[o])===void 0){const h=o.indexOf("/",1);if(h!==-1){const y=o.substr(h);await this.mkdir({path:y,directory:e.directory,recursive:s})}}if(!i&&(t=t.indexOf(",")>=0?t.split(",")[1]:t,!this.isBase64String(t)))throw Error("The supplied data is not valid base64 content.");const c=Date.now(),d={path:r,folder:o,type:"file",size:t.length,ctime:c,mtime:c,content:t};return await this.dbRequest("put",[d]),{uri:d.path}}async appendFile(e){const r=this.getPath(e.directory,e.path);let t=e.data;const i=e.encoding,s=r.substr(0,r.lastIndexOf("/")),a=Date.now();let o=a;const n=await this.dbRequest("get",[r]);if(n&&n.type==="directory")throw Error("The supplied path is a directory.");if(await this.dbRequest("get",[s])===void 0){const h=s.indexOf("/",1);if(h!==-1){const y=s.substr(h);await this.mkdir({path:y,directory:e.directory,recursive:!0})}}if(!i&&!this.isBase64String(t))throw Error("The supplied data is not valid base64 content.");n!==void 0&&(n.content!==void 0&&!i?t=btoa(atob(n.content)+atob(t)):t=n.content+t,o=n.ctime);const d={path:r,folder:s,type:"file",size:t.length,ctime:o,mtime:a,content:t};await this.dbRequest("put",[d])}async deleteFile(e){const r=this.getPath(e.directory,e.path);if(await this.dbRequest("get",[r])===void 0)throw Error("File does not exist.");if((await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)])).length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[r])}async mkdir(e){const r=this.getPath(e.directory,e.path),t=e.recursive,i=r.substr(0,r.lastIndexOf("/")),s=(r.match(/\//g)||[]).length,a=await this.dbRequest("get",[i]),o=await this.dbRequest("get",[r]);if(s===1)throw Error("Cannot create Root directory");if(o!==void 0)throw Error("Current directory does already exist.");if(!t&&s!==2&&a===void 0)throw Error("Parent directory must exist");if(t&&s!==2&&a===void 0){const d=i.substr(i.indexOf("/",1));await this.mkdir({path:d,directory:e.directory,recursive:t})}const n=Date.now(),c={path:r,folder:i,type:"directory",size:0,ctime:n,mtime:n};await this.dbRequest("put",[c])}async rmdir(e){const{path:r,directory:t,recursive:i}=e,s=this.getPath(t,r),a=await this.dbRequest("get",[s]);if(a===void 0)throw Error("Folder does not exist.");if(a.type!=="directory")throw Error("Requested path is not a directory");const o=await this.readdir({path:r,directory:t});if(o.files.length!==0&&!i)throw Error("Folder is not empty");for(const n of o.files){const c=`${r}/${n.name}`;(await this.stat({path:c,directory:t})).type==="file"?await this.deleteFile({path:c,directory:t}):await this.rmdir({path:c,directory:t,recursive:i})}await this.dbRequest("delete",[s])}async readdir(e){const r=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[r]);if(e.path!==""&&t===void 0)throw Error("Folder does not exist.");const i=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)]);return{files:await Promise.all(i.map(async a=>{let o=await this.dbRequest("get",[a]);return o===void 0&&(o=await this.dbRequest("get",[a+"/"])),{name:a.substring(r.length+1),type:o.type,size:o.size,ctime:o.ctime,mtime:o.mtime,uri:o.path}}))}}async getUri(e){const r=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[r]);return t===void 0&&(t=await this.dbRequest("get",[r+"/"])),{uri:(t==null?void 0:t.path)||r}}async stat(e){const r=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[r]);if(t===void 0&&(t=await this.dbRequest("get",[r+"/"])),t===void 0)throw Error("Entry does not exist.");return{type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}}async rename(e){await this._copy(e,!0)}async copy(e){return this._copy(e,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,r=!1){let{toDirectory:t}=e;const{to:i,from:s,directory:a}=e;if(!i||!s)throw Error("Both to and from must be provided");t||(t=a);const o=this.getPath(a,s),n=this.getPath(t,i);if(o===n)return{uri:n};if(E(o,n))throw Error("To path cannot contain the from path");let c;try{c=await this.stat({path:i,directory:t})}catch{const u=i.split("/");u.pop();const f=u.join("/");if(u.length>0&&(await this.stat({path:f,directory:t})).type!=="directory")throw new Error("Parent directory of the to path is a file")}if(c&&c.type==="directory")throw new Error("Cannot overwrite a directory with a file");const d=await this.stat({path:s,directory:a}),h=async(p,u,f)=>{const g=this.getPath(t,p),m=await this.dbRequest("get",[g]);m.ctime=u,m.mtime=f,await this.dbRequest("put",[m])},y=d.ctime?d.ctime:Date.now();switch(d.type){case"file":{const p=await this.readFile({path:s,directory:a});r&&await this.deleteFile({path:s,directory:a});let u;this.isBase64String(p.data)||(u=x.UTF8);const f=await this.writeFile({path:i,directory:t,data:p.data,encoding:u});return r&&await h(i,y,d.mtime),f}case"directory":{if(c)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:i,directory:t,recursive:!1}),r&&await h(i,y,d.mtime)}catch{}const p=(await this.readdir({path:s,directory:a})).files;for(const u of p)await this._copy({from:`${s}/${u.name}`,to:`${i}/${u.name}`,directory:a,toDirectory:t},r);r&&await this.rmdir({path:s,directory:a})}}return{uri:n}}isBase64String(e){try{return btoa(atob(e))==e}catch{return!1}}}w._debug=!0;export{w as FilesystemWeb};
//# sourceMappingURL=web-D6lYl5XJ.js.map
